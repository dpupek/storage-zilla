name: Release MSIX Common

on:
  workflow_call:
    inputs:
      channel:
        description: "Release channel: beta or prod"
        required: true
        type: string
      prerelease:
        description: "Whether to publish as prerelease"
        required: true
        type: boolean
    secrets:
      MSIX_CERT_BASE64:
        required: true
      MSIX_CERT_PASSWORD:
        required: true
      MSIX_PUBLISHER:
        required: false

permissions:
  contents: write

jobs:
  release:
    runs-on: windows-2022

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2
        with:
          msbuild-architecture: x64

      - name: Install NBGV
        shell: pwsh
        run: dotnet tool install --global nbgv

      - name: Compute release version
        id: version
        shell: pwsh
        run: |
          $channel = "${{ inputs.channel }}"
          $json = nbgv get-version -f json
          $info = $json | ConvertFrom-Json
          $baseVersion = [string]$info.SimpleVersion
          if ([string]::IsNullOrWhiteSpace($baseVersion)) {
            throw "Could not resolve base version from NBGV."
          }

          if ($channel -eq "beta") {
            $height = if ($info.VersionHeight -is [int]) { [int]$info.VersionHeight } else { [int]$env:GITHUB_RUN_NUMBER }
            if ($height -le 0) {
              $height = [int]$env:GITHUB_RUN_NUMBER
            }
            $prerelease = "beta.$height"
            $version = "$baseVersion-$prerelease"
            $releaseName = "Storage Zilla Beta v$version"
          } elseif ($channel -eq "prod") {
            $prerelease = ""
            $version = $baseVersion
            $releaseName = "Storage Zilla v$version"
          } else {
            throw "Unsupported channel '$channel'. Expected 'beta' or 'prod'."
          }

          $tag = "v$version"
          "base_version=$baseVersion" >> $env:GITHUB_OUTPUT
          "prerelease=$prerelease" >> $env:GITHUB_OUTPUT
          "version=$version" >> $env:GITHUB_OUTPUT
          "tag=$tag" >> $env:GITHUB_OUTPUT
          "release_name=$releaseName" >> $env:GITHUB_OUTPUT
          "VERSION=$version" >> $env:GITHUB_ENV

      - name: Restore
        shell: pwsh
        run: dotnet restore AzureFilesSync.slnx -r win-x64

      - name: Build
        shell: pwsh
        run: |
          dotnet build AzureFilesSync.slnx `
            -c Release `
            /p:VersionPrefix=${{ steps.version.outputs.base_version }} `
            /p:VersionSuffix=${{ steps.version.outputs.prerelease }}

      - name: Test
        shell: pwsh
        run: |
          dotnet test AzureFilesSync.slnx `
            -c Release `
            --no-build `
            /p:VersionPrefix=${{ steps.version.outputs.base_version }} `
            /p:VersionSuffix=${{ steps.version.outputs.prerelease }}

      - name: Verify assembly informational version is aligned
        shell: pwsh
        run: |
          $dll = Resolve-Path "src/AzureFilesSync.Desktop/bin/Release/net10.0-windows/AzureFilesSync.Desktop.dll"
          $actualRaw = (Get-Item $dll).VersionInfo.ProductVersion
          $actual = ($actualRaw -split '\+')[0]
          $expectedBase = "${{ steps.version.outputs.base_version }}"
          if ($actual -ne $expectedBase) {
            throw "Assembly informational version mismatch. Expected base '$expectedBase' but found '$actualRaw'."
          }

      - name: Prepare signing certificate
        shell: pwsh
        env:
          MSIX_CERT_BASE64: ${{ secrets.MSIX_CERT_BASE64 }}
        run: |
          $certBase64 = $env:MSIX_CERT_BASE64
          if ([string]::IsNullOrWhiteSpace($certBase64)) {
            throw "MSIX_CERT_BASE64 is empty."
          }

          $certPath = Join-Path $env:RUNNER_TEMP "storage-zilla-release.pfx"
          [IO.File]::WriteAllBytes($certPath, [Convert]::FromBase64String($certBase64))
          "MSIX_CERT_PATH=$certPath" >> $env:GITHUB_ENV

      - name: Validate signing certificate
        shell: pwsh
        env:
          MSIX_CERT_PASSWORD: ${{ secrets.MSIX_CERT_PASSWORD }}
        run: |
          $certPassword = $env:MSIX_CERT_PASSWORD
          if ([string]::IsNullOrWhiteSpace($certPassword)) {
            throw "MSIX_CERT_PASSWORD is empty."
          }

          if (-not (Test-Path $env:MSIX_CERT_PATH)) {
            throw "Signing certificate file was not created: $env:MSIX_CERT_PATH"
          }

          try {
            $flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
            $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($env:MSIX_CERT_PATH, $certPassword, $flags)

            if (-not $cert.HasPrivateKey) {
              throw "PFX loaded but does not contain a private key."
            }

            if ($cert.NotAfter -lt (Get-Date)) {
              throw "PFX certificate is expired as of $($cert.NotAfter.ToString('u'))."
            }

            $thumbprint = $cert.Thumbprint
            Write-Host "Signing certificate validated. Subject: $($cert.Subject); Thumbprint: $thumbprint"
            "MSIX_CERT_THUMBPRINT=$thumbprint" >> $env:GITHUB_ENV
            "MSIX_CERT_SUBJECT=$($cert.Subject)" >> $env:GITHUB_ENV
            "MSIX_CERT_NOT_AFTER=$($cert.NotAfter.ToString('u'))" >> $env:GITHUB_ENV
            $cert.Dispose()
          } catch {
            throw "Unable to open MSIX signing certificate. Verify MSIX_CERT_BASE64 and MSIX_CERT_PASSWORD were created from the same PFX export. Details: $($_.Exception.Message)"
          }

      - name: Import signing certificate into CurrentUser store
        shell: pwsh
        env:
          MSIX_CERT_PASSWORD: ${{ secrets.MSIX_CERT_PASSWORD }}
        run: |
          $securePassword = ConvertTo-SecureString $env:MSIX_CERT_PASSWORD -AsPlainText -Force
          Import-PfxCertificate -FilePath $env:MSIX_CERT_PATH -Password $securePassword -CertStoreLocation "Cert:\CurrentUser\My" | Out-Null

      - name: Apply package publisher from secret
        shell: pwsh
        env:
          MSIX_PUBLISHER: ${{ secrets.MSIX_PUBLISHER }}
        run: |
          $manifestPath = "installer/StorageZilla.Package/Package.appxmanifest"
          [xml]$manifest = Get-Content $manifestPath
          $ns = New-Object System.Xml.XmlNamespaceManager($manifest.NameTable)
          $ns.AddNamespace("appx", "http://schemas.microsoft.com/appx/manifest/foundation/windows10")
          $identity = $manifest.SelectSingleNode("/appx:Package/appx:Identity", $ns)
          if ($null -eq $identity) {
            throw "Unable to find Package/Identity node in $manifestPath."
          }
          $publisherFromSecret = $env:MSIX_PUBLISHER
          if ([string]::IsNullOrWhiteSpace($publisherFromSecret)) {
            $existingPublisher = $identity.GetAttribute("Publisher")
            if ([string]::IsNullOrWhiteSpace($existingPublisher)) {
              throw "MSIX_PUBLISHER secret is empty and Package.appxmanifest has no Publisher."
            }
            Write-Host "MSIX_PUBLISHER secret not set; using manifest Publisher '$existingPublisher'."
          } else {
            $identity.SetAttribute("Publisher", $publisherFromSecret)
          }
          $manifest.Save($manifestPath)

      - name: Build signed MSIX package
        shell: pwsh
        env:
          MSIX_CERT_PASSWORD: ${{ secrets.MSIX_CERT_PASSWORD }}
        run: |
          $packageDir = Join-Path $env:RUNNER_TEMP "msix"
          New-Item -ItemType Directory -Path $packageDir -Force | Out-Null

          $msbuildArgs = @(
            "installer/StorageZilla.Package/StorageZilla.Package.wapproj"
            "/p:Configuration=Release"
            "/p:Platform=x64"
            "/p:AppxBundle=Never"
            "/p:UapAppxPackageBuildMode=SideLoadOnly"
            "/p:AppxPackageDir=$packageDir\\"
            "/p:AppxPackageSigningEnabled=true"
            "/p:PackageCertificateThumbprint=$env:MSIX_CERT_THUMBPRINT"
            "/p:PackageCertificateStoreName=My"
            "/p:PackageCertificateStoreLocation=CurrentUser"
            "/p:AppxPackageVersion=${{ steps.version.outputs.base_version }}.0"
            "/p:RuntimeIdentifier=win-x64"
            "/p:SelfContained=true"
            "/p:VersionPrefix=${{ steps.version.outputs.base_version }}"
            "/p:VersionSuffix="
          )
          & msbuild @msbuildArgs

      - name: Publish desktop payload for MSI
        shell: pwsh
        run: |
          $publishDir = Join-Path $env:RUNNER_TEMP "msi-publish"
          New-Item -ItemType Directory -Path $publishDir -Force | Out-Null
          dotnet publish src/AzureFilesSync.Desktop/AzureFilesSync.Desktop.csproj `
            -c Release `
            -r win-x64 `
            --self-contained true `
            -p:PublishSingleFile=false `
            -o $publishDir
          "MSI_PUBLISH_DIR=$publishDir" >> $env:GITHUB_ENV

      - name: Install WiX Toolset
        shell: pwsh
        run: |
          if (-not (Get-Command heat.exe -ErrorAction SilentlyContinue) -or -not (Get-Command candle.exe -ErrorAction SilentlyContinue) -or -not (Get-Command light.exe -ErrorAction SilentlyContinue)) {
            choco install wixtoolset --no-progress -y
          }

      - name: Build unsigned MSI package
        id: msi_artifact
        shell: pwsh
        run: |
          $msiOutDir = Join-Path $env:RUNNER_TEMP "msi"
          New-Item -ItemType Directory -Path $msiOutDir -Force | Out-Null

          $harvestFile = Join-Path $env:RUNNER_TEMP "StorageZilla.Files.wxs"
          & heat dir "$env:MSI_PUBLISH_DIR" `
            -cg AppFiles `
            -dr INSTALLFOLDER `
            -srd `
            -sreg `
            -scom `
            -gg `
            -var var.PublishDir `
            -out "$harvestFile"

          & candle `
            -nologo `
            -arch x64 `
            -ext WixUIExtension `
            -dInstallerRoot="installer\\StorageZilla.Msi" `
            -dPublishDir="$env:MSI_PUBLISH_DIR" `
            -dProductVersion="${{ steps.version.outputs.base_version }}.0" `
            -out "$env:RUNNER_TEMP\\" `
            installer/StorageZilla.Msi/Product.wxs `
            "$harvestFile"

          $productObj = Join-Path $env:RUNNER_TEMP "Product.wixobj"
          $filesObj = Join-Path $env:RUNNER_TEMP "StorageZilla.Files.wixobj"
          $msiPath = Join-Path $msiOutDir "StorageZilla_${{ steps.version.outputs.version }}_x64_unsigned.msi"

          & light `
            -nologo `
            -ext WixUIExtension `
            -out "$msiPath" `
            "$productObj" `
            "$filesObj"

          "msi_path=$msiPath" >> $env:GITHUB_OUTPUT

      - name: Build portable zip package
        id: zip_artifact
        shell: pwsh
        run: |
          $zipOutDir = Join-Path $env:RUNNER_TEMP "zip"
          New-Item -ItemType Directory -Path $zipOutDir -Force | Out-Null
          $zipPath = Join-Path $zipOutDir "StorageZilla_${{ steps.version.outputs.version }}_win-x64_portable.zip"
          if (Test-Path $zipPath) {
            Remove-Item $zipPath -Force
          }

          Compress-Archive -Path (Join-Path "$env:MSI_PUBLISH_DIR" '*') -DestinationPath $zipPath -CompressionLevel Optimal
          "zip_path=$zipPath" >> $env:GITHUB_OUTPUT

      - name: Export public signing certificate
        id: cert_artifact
        shell: pwsh
        run: |
          $certOutDir = Join-Path $env:RUNNER_TEMP "cert"
          New-Item -ItemType Directory -Path $certOutDir -Force | Out-Null
          $cerPath = Join-Path $certOutDir "StorageZilla-Signing-PublicKey.cer"
          Export-Certificate -Cert "Cert:\CurrentUser\My\$env:MSIX_CERT_THUMBPRINT" -FilePath $cerPath -Type CERT | Out-Null
          "cer_path=$cerPath" >> $env:GITHUB_OUTPUT

      - name: Write release notes artifact
        id: notes_artifact
        shell: pwsh
        run: |
          $notesOutDir = Join-Path $env:RUNNER_TEMP "notes"
          New-Item -ItemType Directory -Path $notesOutDir -Force | Out-Null
          $notesPath = Join-Path $notesOutDir "RELEASE-NOTES.md"
          $channel = "${{ inputs.channel }}"
          $lines = @(
            "# Storage Zilla Release Notes"
            ""
            "## Release"
            "- Version: ${{ steps.version.outputs.version }}"
            "- Tag: ${{ steps.version.outputs.tag }}"
            "- Channel: $channel"
            ""
            "## Artifacts"
            "- Signed MSIX package"
            "- Unsigned MSI package"
            "- Portable ZIP package (self-contained binaries)"
            "- SHA256 checksums (SHA256SUMS.txt)"
            "- Public signing certificate (StorageZilla-Signing-PublicKey.cer)"
            ""
            "## Trust"
            "- Certificate Subject: $env:MSIX_CERT_SUBJECT"
            "- Certificate Thumbprint: $env:MSIX_CERT_THUMBPRINT"
            "- Certificate Expiration (UTC): $env:MSIX_CERT_NOT_AFTER"
          )
          Set-Content -Path $notesPath -Value $lines -Encoding UTF8
          "notes_path=$notesPath" >> $env:GITHUB_OUTPUT

      - name: Resolve MSIX artifact
        id: artifact
        shell: pwsh
        run: |
          $msix = Get-ChildItem -Path (Join-Path $env:RUNNER_TEMP "msix") -Recurse -Filter *.msix | Select-Object -First 1
          if ($null -eq $msix) {
            throw "No .msix artifact was produced."
          }
          "msix_path=$($msix.FullName)" >> $env:GITHUB_OUTPUT

      - name: Write SHA256
        shell: pwsh
        run: |
          $hashes = @(
            Get-FileHash "${{ steps.artifact.outputs.msix_path }}" -Algorithm SHA256
            Get-FileHash "${{ steps.msi_artifact.outputs.msi_path }}" -Algorithm SHA256
            Get-FileHash "${{ steps.zip_artifact.outputs.zip_path }}" -Algorithm SHA256
            Get-FileHash "${{ steps.cert_artifact.outputs.cer_path }}" -Algorithm SHA256
          )
          $line = $hashes | ForEach-Object { "$($_.Hash.ToLowerInvariant()) *$([IO.Path]::GetFileName($_.Path))" }
          $shaPath = Join-Path (Split-Path "${{ steps.artifact.outputs.msix_path }}" -Parent) "SHA256SUMS.txt"
          Set-Content -Path $shaPath -Value $line

      - name: Publish GitHub release
        uses: softprops/action-gh-release@v2
        with:
          prerelease: ${{ inputs.prerelease }}
          tag_name: ${{ steps.version.outputs.tag }}
          target_commitish: ${{ github.sha }}
          name: ${{ steps.version.outputs.release_name }}
          generate_release_notes: true
          files: |
            ${{ steps.artifact.outputs.msix_path }}
            ${{ steps.msi_artifact.outputs.msi_path }}
            ${{ steps.zip_artifact.outputs.zip_path }}
            ${{ steps.cert_artifact.outputs.cer_path }}
            ${{ steps.notes_artifact.outputs.notes_path }}
            ${{ runner.temp }}\msix\SHA256SUMS.txt
