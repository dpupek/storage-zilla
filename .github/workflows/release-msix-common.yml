name: Release MSIX Common

on:
  workflow_call:
    inputs:
      channel:
        description: "Release channel: beta or prod"
        required: true
        type: string
      prerelease:
        description: "Whether to publish as prerelease"
        required: true
        type: boolean
    secrets:
      MSIX_CERT_BASE64:
        required: true
      MSIX_CERT_PASSWORD:
        required: true
      MSIX_PUBLISHER:
        required: false

permissions:
  contents: write

jobs:
  release:
    runs-on: windows-2022

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2
        with:
          msbuild-architecture: x64

      - name: Install NBGV
        shell: pwsh
        run: dotnet tool install --global nbgv

      - name: Compute release version
        id: version
        shell: pwsh
        run: |
          $channel = "${{ inputs.channel }}"
          $json = nbgv get-version -f json
          $info = $json | ConvertFrom-Json
          $baseVersion = [string]$info.SimpleVersion
          if ([string]::IsNullOrWhiteSpace($baseVersion)) {
            throw "Could not resolve base version from NBGV."
          }

          if ($channel -eq "beta") {
            $height = if ($info.VersionHeight -is [int]) { [int]$info.VersionHeight } else { [int]$env:GITHUB_RUN_NUMBER }
            if ($height -le 0) {
              $height = [int]$env:GITHUB_RUN_NUMBER
            }
            $prerelease = "beta.$height"
            $version = "$baseVersion-$prerelease"
            $releaseName = "Storage Zilla Beta v$version"
          } elseif ($channel -eq "prod") {
            $prerelease = ""
            $version = $baseVersion
            $releaseName = "Storage Zilla v$version"
          } else {
            throw "Unsupported channel '$channel'. Expected 'beta' or 'prod'."
          }

          $tag = "v$version"
          "base_version=$baseVersion" >> $env:GITHUB_OUTPUT
          "prerelease=$prerelease" >> $env:GITHUB_OUTPUT
          "version=$version" >> $env:GITHUB_OUTPUT
          "tag=$tag" >> $env:GITHUB_OUTPUT
          "release_name=$releaseName" >> $env:GITHUB_OUTPUT
          "VERSION=$version" >> $env:GITHUB_ENV

      - name: Restore
        shell: pwsh
        run: dotnet restore AzureFilesSync.slnx -r win-x64

      - name: Build
        shell: pwsh
        run: |
          dotnet build AzureFilesSync.slnx `
            -c Release `
            /p:VersionPrefix=${{ steps.version.outputs.base_version }} `
            /p:VersionSuffix=${{ steps.version.outputs.prerelease }}

      - name: Test
        shell: pwsh
        run: |
          dotnet test AzureFilesSync.slnx `
            -c Release `
            --no-build `
            /p:VersionPrefix=${{ steps.version.outputs.base_version }} `
            /p:VersionSuffix=${{ steps.version.outputs.prerelease }}

      - name: Verify assembly informational version is aligned
        shell: pwsh
        run: |
          $dll = Resolve-Path "src/AzureFilesSync.Desktop/bin/Release/net10.0-windows/AzureFilesSync.Desktop.dll"
          $actualRaw = (Get-Item $dll).VersionInfo.ProductVersion
          $actual = ($actualRaw -split '\+')[0]
          $expectedBase = "${{ steps.version.outputs.base_version }}"
          if ($actual -ne $expectedBase) {
            throw "Assembly informational version mismatch. Expected base '$expectedBase' but found '$actualRaw'."
          }

      - name: Prepare signing certificate
        shell: pwsh
        run: |
          $certBase64 = "${{ secrets.MSIX_CERT_BASE64 }}"
          if ([string]::IsNullOrWhiteSpace($certBase64)) {
            throw "MSIX_CERT_BASE64 is empty."
          }

          $certPath = Join-Path $env:RUNNER_TEMP "storage-zilla-release.pfx"
          [IO.File]::WriteAllBytes($certPath, [Convert]::FromBase64String($certBase64))
          "MSIX_CERT_PATH=$certPath" >> $env:GITHUB_ENV

      - name: Validate signing certificate
        shell: pwsh
        run: |
          $certPassword = "${{ secrets.MSIX_CERT_PASSWORD }}"
          if ([string]::IsNullOrWhiteSpace($certPassword)) {
            throw "MSIX_CERT_PASSWORD is empty."
          }

          if (-not (Test-Path $env:MSIX_CERT_PATH)) {
            throw "Signing certificate file was not created: $env:MSIX_CERT_PATH"
          }

          try {
            $flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
            $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new($env:MSIX_CERT_PATH, $certPassword, $flags)

            if (-not $cert.HasPrivateKey) {
              throw "PFX loaded but does not contain a private key."
            }

            if ($cert.NotAfter -lt (Get-Date)) {
              throw "PFX certificate is expired as of $($cert.NotAfter.ToString('u'))."
            }

            Write-Host "Signing certificate validated. Subject: $($cert.Subject); Thumbprint: $($cert.Thumbprint)"
            $cert.Dispose()
          } catch {
            throw "Unable to open MSIX signing certificate. Verify MSIX_CERT_BASE64 and MSIX_CERT_PASSWORD were created from the same PFX export. Details: $($_.Exception.Message)"
          }

      - name: Apply package publisher from secret
        shell: pwsh
        run: |
          $manifestPath = "installer/StorageZilla.Package/Package.appxmanifest"
          [xml]$manifest = Get-Content $manifestPath
          $ns = New-Object System.Xml.XmlNamespaceManager($manifest.NameTable)
          $ns.AddNamespace("appx", "http://schemas.microsoft.com/appx/manifest/foundation/windows10")
          $identity = $manifest.SelectSingleNode("/appx:Package/appx:Identity", $ns)
          if ($null -eq $identity) {
            throw "Unable to find Package/Identity node in $manifestPath."
          }
          $publisherFromSecret = "${{ secrets.MSIX_PUBLISHER }}"
          if ([string]::IsNullOrWhiteSpace($publisherFromSecret)) {
            $existingPublisher = $identity.GetAttribute("Publisher")
            if ([string]::IsNullOrWhiteSpace($existingPublisher)) {
              throw "MSIX_PUBLISHER secret is empty and Package.appxmanifest has no Publisher."
            }
            Write-Host "MSIX_PUBLISHER secret not set; using manifest Publisher '$existingPublisher'."
          } else {
            $identity.SetAttribute("Publisher", $publisherFromSecret)
          }
          $manifest.Save($manifestPath)

      - name: Build signed MSIX package
        shell: pwsh
        run: |
          $packageDir = Join-Path $env:RUNNER_TEMP "msix"
          New-Item -ItemType Directory -Path $packageDir -Force | Out-Null

          msbuild installer/StorageZilla.Package/StorageZilla.Package.wapproj `
            /p:Configuration=Release `
            /p:Platform=x64 `
            /p:AppxBundle=Never `
            /p:UapAppxPackageBuildMode=SideLoadOnly `
            /p:AppxPackageDir="$packageDir\\" `
            /p:AppxPackageSigningEnabled=true `
            /p:PackageCertificateKeyFile="$env:MSIX_CERT_PATH" `
            /p:PackageCertificatePassword="${{ secrets.MSIX_CERT_PASSWORD }}" `
            /p:AppxPackageVersion="${{ steps.version.outputs.base_version }}.0" `
            /p:RuntimeIdentifier=win-x64 `
            /p:SelfContained=true `
            /p:VersionPrefix=${{ steps.version.outputs.base_version }} `
            /p:VersionSuffix=

      - name: Resolve MSIX artifact
        id: artifact
        shell: pwsh
        run: |
          $msix = Get-ChildItem -Path (Join-Path $env:RUNNER_TEMP "msix") -Recurse -Filter *.msix | Select-Object -First 1
          if ($null -eq $msix) {
            throw "No .msix artifact was produced."
          }
          "msix_path=$($msix.FullName)" >> $env:GITHUB_OUTPUT

      - name: Write SHA256
        shell: pwsh
        run: |
          $hash = Get-FileHash "${{ steps.artifact.outputs.msix_path }}" -Algorithm SHA256
          $line = "$($hash.Hash.ToLowerInvariant()) *$([IO.Path]::GetFileName($hash.Path))"
          $shaPath = Join-Path (Split-Path "${{ steps.artifact.outputs.msix_path }}" -Parent) "SHA256SUMS.txt"
          Set-Content -Path $shaPath -Value $line -NoNewline

      - name: Publish GitHub release
        uses: softprops/action-gh-release@v2
        with:
          prerelease: ${{ inputs.prerelease }}
          tag_name: ${{ steps.version.outputs.tag }}
          target_commitish: ${{ github.sha }}
          name: ${{ steps.version.outputs.release_name }}
          generate_release_notes: true
          files: |
            ${{ steps.artifact.outputs.msix_path }}
            ${{ runner.temp }}\msix\SHA256SUMS.txt
